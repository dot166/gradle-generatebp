/*
 * SPDX-FileCopyrightText: 2023-2025 The LineageOS Project
 * SPDX-License-Identifier: Apache-2.0
 */

package org.lineageos.generatebp

import org.gradle.api.Project
import org.gradle.api.artifacts.ResolvedConfiguration
import org.gradle.api.artifacts.ResolvedDependency
import org.gradle.kotlin.dsl.get
import org.lineageos.generatebp.ext.getRecursiveDependencies
import org.lineageos.generatebp.ext.indentWithSpaces
import org.lineageos.generatebp.ext.spaces
import org.lineageos.generatebp.ext.toModule
import org.lineageos.generatebp.ext.toModuleIdentifier
import org.lineageos.generatebp.models.Artifact
import org.lineageos.generatebp.models.Module
import org.lineageos.generatebp.models.ModuleIdentifier
import org.lineageos.generatebp.models.ModuleQuirk
import org.lineageos.generatebp.utils.Constants
import org.lineageos.generatebp.utils.Constants.getAospModuleNameFixup
import org.lineageos.generatebp.utils.Constants.getModuleQuirk
import org.lineageos.generatebp.utils.ReuseUtils.writeCopyrightFileForFile
import java.io.File

internal class GenerateBp(
    private val project: Project,
    private val targetSdk: Int,
    private val minSdk: Int,
    private val isAvailableInAOSP: (module: Module) -> Boolean,
    private val libsBase: File = File("${project.projectDir.absolutePath}/libs"),
) {
    /**
     * The Gradle [ResolvedConfiguration] for release build, runtime only dependencies.
     */
    private val resolvedConfiguration = project.configurations[
        "releaseRuntimeClasspath"
    ].resolvedConfiguration

    /**
     * All the dependencies, including transitive dependencies. Quirks aren't applied yet.
     */
    private val allDependencies = resolvedConfiguration.firstLevelModuleDependencies.asSequence()
        .flatMap { it.getRecursiveDependencies() }
        .distinct()
        .associate { moduleIdentifier ->
            moduleIdentifier.toModule(targetSdk).let {
                it as ModuleIdentifier to it
            }
        }

    /**
     * The first level dependencies. Quirks aren't applied yet.
     */
    private val firstLevelDependencies =
        resolvedConfiguration.firstLevelModuleDependencies.asSequence()
            .map(ResolvedDependency::toModuleIdentifier)
            .distinct()

    /**
     * All the dependencies, including transitive dependencies, with quirks applied.
     */
    private val finalDependencies = firstLevelDependencies
        .flatMap { it.getRecursiveDependencies() }
        .distinct()

    /**
     * All the dependencies that aren't in the AOSP tree.
     */
    private val nonAospDependencies = firstLevelDependencies
        .flatMap { it.getModule().getAllNonAospTransitiveDependencies() }
        .toSet()

    /**
     * The final list of shared libraries that the app should declare as first level dependencies.
     */
    private val appSharedLibs = firstLevelDependencies
        .applyQuirks()
        .plus(finalDependencies.filter(Module::treatAsFirstLevelDependency))
        .toSet()

    operator fun invoke() {
        // Delete old libs artifacts
        libsBase.deleteRecursively()

        // Update app/Android.bp
        File("${project.projectDir.absolutePath}/Android.bp").let { file ->
            val dependenciesString = buildString {
                append("\n")
                append(Constants.SHARED_LIBS_HEADER.indentWithSpaces(8))
                append("\n")
                append(
                    appSharedLibs.sorted().map {
                        "\"${it.getAospModuleName()}\","
                    }.indentWithSpaces(8).joinToString("\n")
                )
                append("\n${spaces(4)}")
            }

            file.writeText(
                file.readText().replace(
                    // Replace existing dependencies with newly generated ones
                    "static_libs: \\[.*?]".toRegex(RegexOption.DOT_MATCHES_ALL),
                    "static_libs: [%s]".format(dependenciesString)
                ).replace(
                    // Replace existing sdk_version with one from targetSdk
                    "sdk_version: \"\\d+\"".toRegex(),
                    "sdk_version: \"${targetSdk}\""
                )
            )
        }

        // Update app/libs
        nonAospDependencies.sorted().forEach {
            // Create dir
            libsBase.mkdirs()

            it.artifact?.let { artifact ->
                // Get file path
                val dirPath = "${libsBase}/${it.aospModulePath}"
                val filePath = "${dirPath}/${artifact.file.name}"

                // Copy artifact to app/libs
                artifact.file.copyTo(File(filePath))

                // Write license file
                artifact.writeCopyrightFileForFile(filePath)
            }

            // Write Android.bp
            File("$libsBase/Android.bp").let { file ->
                // Add autogenerated header if file is empty
                if (file.length() == 0L) {
                    file.writeText(Constants.libsAndroidBpHeader)
                }

                it.artifact?.also { artifact ->
                    val artifactMinSdkVersion = artifact.minSdkVersion ?: minSdk
                    require(artifactMinSdkVersion >= minSdk) {
                        "Artifact ${artifact.file.name} has minSdkVersion $artifactMinSdkVersion " +
                                "which is lower than the project minSdkVersion $minSdk"
                    }

                    when (artifact.fileType) {
                        Artifact.FileType.AAR -> {
                            file.appendText(
                                """

                                android_library_import {
                                    name: "${it.getAospModuleName()}",
                                    aars: ["${it.aospModulePath}/${artifact.file.name}"],
                                    sdk_version: "${artifact.targetSdkVersion}",
                                    min_sdk_version: "$minSdk",
                                    apex_available: [
                                        "//apex_available:platform",
                                        "//apex_available:anyapex",
                                    ],
                                    static_libs: [%s],${
                                    when (artifact.containsJniLibs) {
                                        true -> """
                                    extract_jni: true,"""

                                        false -> ""
                                    }
                                }
                                }

                                """.trimIndent().format(
                                    it.formatDependencies()
                                )
                            )
                        }

                        Artifact.FileType.JAR -> {
                            file.appendText(
                                """
    
                                java_import {
                                    name: "${it.getAospModuleName()}",
                                    jars: ["${it.aospModulePath}/${artifact.file.name}"],
                                    sdk_version: "${artifact.targetSdkVersion}",
                                    min_sdk_version: "$minSdk",
                                    apex_available: [
                                        "//apex_available:platform",
                                        "//apex_available:anyapex",
                                    ],
                                    static_libs: [%s],
                                }

                                """.trimIndent().format(
                                    it.formatDependencies()
                                )
                            )
                        }
                    }
                } ?: file.appendText(
                    """

                    java_library_static {
                        name: "${it.getAospModuleName()}",
                        sdk_version: "$targetSdk",
                        min_sdk_version: "$minSdk",
                        apex_available: [
                            "//apex_available:platform",
                            "//apex_available:anyapex",
                        ],
                        static_libs: [%s],
                    }

                    """.trimIndent().format(
                        it.formatDependencies()
                    )
                )
            }
        }
    }

    /**
     * Get the name of this [ModuleIdentifier] in the AOSP build system.
     */
    private fun ModuleIdentifier.getAospModuleName() = when (isAvailableInAOSP(getModule())) {
        true -> getAospModuleNameFixup() ?: "${group}_${name}"
        false -> "${project.rootProject.name}_${group}_${name}"
    }

    /**
     * Get all the [Module]s that aren't available in AOSP. Quirks will also be taken into account,
     * with quirks having priority over [isAvailableInAOSP].
     */
    private fun Module.getAllNonAospTransitiveDependencies(): Set<Module> = buildSet {
        val moduleQuirk = getModuleQuirk()

        when (moduleQuirk) {
            ModuleQuirk.IGNORE -> {}

            ModuleQuirk.INHERIT_DEPENDENCIES -> dependencies.getModules().forEach { module ->
                addAll(module.getAllNonAospTransitiveDependencies())
            }

            null -> if (!isAvailableInAOSP(this@getAllNonAospTransitiveDependencies)) {
                add(this@getAllNonAospTransitiveDependencies)

                dependencies.getModules().forEach { module ->
                    addAll(module.getAllNonAospTransitiveDependencies())
                }
            }
        }
    }

    /**
     * Get a formatted list of dependencies for this [Module]'s Android.bp module.
     */
    private fun Module.formatDependencies() = dependencies.asSequence()
        .applyQuirks()
        .distinct()
        .sorted()
        .map { "\"${it.getAospModuleName()}\"," }
        .indentWithSpaces(8)
        .joinToString(separator = "", postfix = "\n${spaces(4)}") { "\n$it" }

    /**
     * Recursively apply the effects of the quirks to this [Sequence] of [ModuleIdentifier]s.
     */
    private fun Sequence<ModuleIdentifier>.applyQuirks(): Sequence<ModuleIdentifier> = flatMap {
        when (it.getModuleQuirk()) {
            ModuleQuirk.IGNORE -> sequenceOf()

            ModuleQuirk.INHERIT_DEPENDENCIES ->
                it.getModule().dependencies.asSequence().applyQuirks()

            null -> sequenceOf(it)
        }
    }

    /**
     * Get all the [ModuleIdentifier]s that are transitive dependencies of this [ModuleIdentifier].
     * This [ModuleIdentifier] will also be included in the result.
     * Quirks will also be applied to both this and the transitive dependencies.
     */
    private fun ModuleIdentifier.getRecursiveDependencies(): Set<Module> = buildSet {
        when (getModuleQuirk()) {
            ModuleQuirk.IGNORE -> {}

            ModuleQuirk.INHERIT_DEPENDENCIES -> getModule().dependencies.forEach {
                addAll(it.getRecursiveDependencies())
            }

            null -> {
                val module = getModule()

                add(module)

                module.dependencies.forEach {
                    addAll(it.getRecursiveDependencies())
                }
            }
        }
    }

    private fun ModuleIdentifier.getModule() = allDependencies[this] ?: error(
        "Cannot find $this in the dependency graph"
    )

    private fun Iterable<ModuleIdentifier>.getModules() = map { it.getModule() }
}
